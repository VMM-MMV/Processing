/* autogenerated by Processing revision 1293 on 2023-10-09 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Processing extends PApplet {

ArrayList<PVector> cubes = new ArrayList<PVector>();
ArrayList<PVector> spheres = new ArrayList<PVector>();
ArrayList<PVector> bullets = new ArrayList<PVector>();

ArrayList<PVector> cubeRotations = new ArrayList<PVector>();
ArrayList<PVector> sphereRotations = new ArrayList<PVector>();

ArrayList<PVector> cubeCurrentRotations = new ArrayList<PVector>();
ArrayList<PVector> sphereCurrentRotations = new ArrayList<PVector>();

int bulletAmount = 100;
int enemiesAmount = 0;
String gameState = "menu";
int difficulty = 1;
int minutes;
int seconds;

int startTime;
int elapsedTime;

public void setup() {
  /* size commented out by preprocessor */;
}

public void displayMenu() {
  textSize(48);
  fill(255, 0, 0);
  textAlign(CENTER, CENTER);
  text("EASY", 100, height / 2);
  text("MEDIUM", 300, height / 2);
  text("HARD", 500, height / 2);
  text("HELL", 700, height / 2);
}


public void checkGameOver() {
  if (bulletAmount <= 0 || (cubes.size() + spheres.size()) >= 30) {
    gameState = "end";
  }
}

public void displayGameOver() {
  textSize(48);
  fill(255, 0, 0);
  textAlign(CENTER, CENTER);
  text("YOU LOSE" + "\nYOUR TIME: " + minutes + ":" + seconds , width / 2, height / 2);
}

public int probabilisticFunction() {
  if (random(1) < 0.5f) {
    return 2;
  } else {
    return 1;
  }
}

public void bullet_collisions(PVector bullet, ArrayList<PVector> objects, ArrayList<PVector> rotations, ArrayList<PVector> currentRotations) {
    for (int j = objects.size() - 1; j >= 0; j--) {
        PVector obj = objects.get(j);
        if (dist(bullet.x, bullet.y, bullet.z, obj.x, obj.y, obj.z) < 50) {
            objects.remove(j);
            rotations.remove(j);
            currentRotations.remove(j);
            bullets.remove(bullet);
            bulletAmount += probabilisticFunction();
            break;
        }
    }
}

public void spawnCubes() {
    if (random(100) < difficulty) {
        cubes.add(new PVector(random(100, width-100), random(100, height-100), random(-300, -100)));
        cubeRotations.add(new PVector(random(-0.1f, 0.1f), random(-0.1f, 0.1f), random(-0.1f, 0.1f)));
        cubeCurrentRotations.add(new PVector(0, 0, 0));
    }
    renderCubes();
}

public void spawnSpheres() {
    if (random(100) < difficulty) {
        spheres.add(new PVector(random(100, width-100), random(100, height-100), random(-300, -100)));
        sphereRotations.add(new PVector(random(-0.1f, 0.1f), random(-0.1f, 0.1f), random(-0.1f, 0.1f)));
        sphereCurrentRotations.add(new PVector(0, 0, 0));
    }
    renderSpheres();
}

public void renderCubes() {
    for (int i = 0; i < cubes.size(); i++) {
        PVector cube = cubes.get(i);
        PVector rotationSpeed = cubeRotations.get(i);
        PVector currentRotation = cubeCurrentRotations.get(i);
        
        currentRotation.add(rotationSpeed);
        
        pushMatrix();
        translate(cube.x, cube.y, cube.z);
        rotateX(currentRotation.x);
        rotateY(currentRotation.y);
        rotateZ(currentRotation.z);
        box(50);
        popMatrix();
    }
}

public void renderSpheres() {
    for (int i = 0; i < spheres.size(); i++) {
        PVector sphere = spheres.get(i);
        PVector rotationSpeed = sphereRotations.get(i);
        PVector currentRotation = sphereCurrentRotations.get(i);
        
        currentRotation.add(rotationSpeed);
        
        pushMatrix();
        translate(sphere.x, sphere.y, sphere.z);
        rotateX(currentRotation.x);
        rotateY(currentRotation.y);
        rotateZ(currentRotation.z);
        sphere(30);
        popMatrix();
    }
}

public void bulletText() {
  textSize(24);
  fill(0);
  textAlign(RIGHT, TOP);
  text("Bullets: " + bulletAmount, width - 10, 10);
}

public void enemiesText() {
  textSize(24);
  fill(0);
  textAlign(LEFT, TOP);
  text("Enemies: " + PApplet.parseInt(cubes.size() + spheres.size()), 10, 10);
}

public void displayElapsedTime() {
  elapsedTime = (millis() - startTime) / 1000;
  minutes = elapsedTime / 60;
  seconds = elapsedTime % 60;
  
  textSize(24);
  fill(0);
  textAlign(RIGHT, BOTTOM);
  text("Time: " + nf(minutes, 2) + ":" + nf(seconds, 2), width - 10, height - 10);
}


public void draw() {
  background(200);
  lights();
  checkGameOver();
  if (gameState.equals("menu")) {
    displayMenu();
  } else if (gameState.equals("play")) {
    bulletText();
    enemiesText();
    displayElapsedTime();

      fill(255);
      spawnCubes();
      spawnSpheres();
      
      for (int i = bullets.size() - 1; i >= 0; i--) {
        PVector bullet = bullets.get(i);
        bullet.z -= 10;
        pushMatrix();
        translate(bullet.x, bullet.y, bullet.z);
        sphere(5);
        popMatrix();
        
        bullet_collisions(bullet, cubes, cubeRotations, cubeCurrentRotations);
        bullet_collisions(bullet, spheres, sphereRotations, sphereCurrentRotations);
        if (bullet.z < -500) {
          bullets.remove(bullet);
        } 
      }
  } else if (gameState.equals("end")) {
    displayGameOver();
  }
}

public void menu() {
  if (mouseX < width / 3) {
      difficulty = 1;
    } else if (mouseX < 2 * width / 3) {
      difficulty = 2;
      int bulletAmount = 50;
    } else if (mouseY < height / 2) {
      difficulty = 3;
      int bulletAmount = 25;
    } else {
      difficulty = 4;
      int bulletAmount = 10;
    }
    startTime = millis();
    gameState = "play";
}

public void mousePressed() {
  if (gameState.equals("menu")) {
    menu();
  } else if (gameState.equals("play") && mouseButton == LEFT && bulletAmount > 0) {
    bullets.add(new PVector(mouseX, mouseY, 0));
    bulletAmount -= 1;
  }
}


  public void settings() { size(800, 600, P3D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Processing" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
